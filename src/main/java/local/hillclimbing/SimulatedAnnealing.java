package local.hillclimbing;

import java.util.Random;

import core.Heuristic;
import core.State;

/**
 * Implements the simulated annealing variant of hill-climbing: prefer quality-improving moves, but allow random quality-decreasing moves. Slowly lower the tolerance for these
 * quality-decreasing moves until it hits zero, turning this algorithm into first choice hill-climbing.
 */
public class SimulatedAnnealing<S extends State<S>> extends AbstractHillClimbing<S> {
	/** The virtual temperature of the search space, which is being annealed. The higher the temperature, the more random the movement through the search space. */
	protected double temperature;
	/** The rate at which the temperature falls. */
	protected final double coolingRate;
	/** The maximum number of unacceptable successor states generated by one iteration of the algorithm before it exits. */
	protected final int maximumSuccessorChecks;
	
	public SimulatedAnnealing(S startState, Heuristic<S> heuristic, double coolingRate, int maximumSuccessorChecks) {
		super(startState, heuristic, 0);
		this.coolingRate = coolingRate;
		this.maximumSuccessorChecks = maximumSuccessorChecks;
		temperature = 1;
		allowDownhillMoves = true;
	}
	
	@Override
	protected S determineSuccessorState() {
		// Decrease the temperature.
		temperature -= coolingRate;
		
		Random rng = new Random();
		int nrSuccessorsChecked = 0;
		while (true) {
			nrSuccessorsChecked++;
			if (nrSuccessorsChecked >= maximumSuccessorChecks) {
				// No acceptable successors were found before the maximum number of checks was reached. Return null to signify that the search has ended.
				return null;
			}
			
			// Choose a prospective successor randomly from all possible successors.
			S possibleSuccessor = currentState.randomlySelectAvailableAction().getResultingState();
			if (heuristic.determineQualityScore(possibleSuccessor) > heuristic.determineQualityScore(currentState)
					|| rng.nextDouble() < temperature) {
				// Either this successor is superior to the current state, or choosing an inferior successor is acceptable. Accept it as the next state.
				return possibleSuccessor;
			}
		}
	}
	
	@Override
	protected void logStatus() {
		log.trace("Current state:\n{}", currentState);
		log.debug("Current state quality is {}, current temparture is {}.", currentState.getQualityScore(), temperature);
	}
}
