package nl.calmamity.search.local.hillclimbing

import nl.calmamity.search.core.{Heuristic, State}

/**
 * Implements the simulated annealing variant of hill-climbing: prefer quality-improving moves, but allow random quality-decreasing moves. Slowly lower the tolerance for these
 * quality-decreasing moves until it hits zero, turning this algorithm into first choice hill-climbing.
 */
	/** The virtual temperature of the search space, which is being annealed. The higher the temperature, the more random the movement through the search space. */
	/** The rate at which the temperature falls. */
	/** The maximum number of unacceptable successor states generated by one iteration of the algorithm before it exits. */
class SimulatedAnnealing[StateImplementation <: State[StateImplementation]](
	val startState: StateImplementation
	, val heuristic: Heuristic[StateImplementation]
	, coolingRate: Double
	, maximumSuccessorChecks: Int
) extends AbstractHillClimbing[StateImplementation] {
	override val maximumNumPlateauMoves: Int = 0
	var temperature: Double = 1
	override val allowDownhillMoves: Boolean = true
	val randomNumbers = new scala.util.Random()
	
	override def determineSuccessorState(currentState: StateImplementation): Option[StateImplementation] = {
		// Decrease the temperature.
		temperature -= coolingRate
		
		def findSuccessor(nrSuccessorsChecked: Int): Option[StateImplementation] = {
			if (nrSuccessorsChecked >= maximumSuccessorChecks) {
				// No acceptable successors were found before the maximum number of checks was reached. Return null to
				// signify that the search has ended.
				None
			} else {
				// Choose a prospective successor randomly from all possible successors.
				val possibleSuccessor: StateImplementation = currentState.randomlySelectAvailableAction.getResultingState
				if (
					heuristic.determineQualityScore(possibleSuccessor) > heuristic.determineQualityScore(currentState)
					|| randomNumbers.nextDouble() < temperature
				) {
					// Either this successor is superior to the current state, or choosing an inferior successor is
					// acceptable. Accept it as the next state.
					Some(possibleSuccessor)
				} else {
					findSuccessor(nrSuccessorsChecked + 1)
				}
			}
		}
		
		findSuccessor(0)
	}
	
	override def logStatus(currentState: StateImplementation): Unit = {
		log.trace("Current state:\n{}", currentState)
		log.debug(
			s"Current state quality is ${heuristic.determineQualityScore(currentState)}, current temparture is " +
				s"$temperature."
		)
	}
}
